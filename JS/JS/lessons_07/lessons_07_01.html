<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <p id="p">nodeType</p>
    <span class="s">span1</span>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
    <span>span2</span>
    <input type="text" name="username">
    <input type="password" name="password">
    <input type="password" name="password">
</body>
<script>
    // DOM : Document Object Model 文档对象模型，作用：在浏览器加载文档时，将文档内容转化成js对象，实现js代码对文档内容的操作-
    //       增删改查.DOM是浏览器提供的对文档内容操作的接口

    // DOM树：文档内容转化后的对象结构像是一个树形结构，根对象就是document，docuemnt对象在文档加载到浏览器中就已经存在，
    //        可以直接使用

    // docuemnt根对象下有两个子对象，分别是：DOCTYPE以及HTML、、
    // DOM中的最小组成部分叫做节点（Node），节点类型有很多，我们常见的有element元素节点、text文本节点。
    // html就是整个文档的根元素节点(有两个子元素：head和body)

    // 节点类型：
    // 1.nodeType:返回节点类型  所有节点都拥有的属性，返回值是number：1，表示节点类型，1为元素节点，3为文本节点
    var p = document.getElementById('p');
    console.log(p.nodeType);

    // 节点名称：
    // nodeName:所有节点都拥有的属性，返回值是string，表示节点名称，如果节点是元素节点，那么会返回大写的标签名
    console.log(document.body.firstChild.nodeName);

    // 节点操作
    // 获取节点
    // html作为文档的根节点，下面只有两个子节点，分别是head和body
    // document.head获取head节点
    console.log( document.head);
    // document.body获取body节点
    console.log( document.body);
    // 以上两个节点都是元素节点

    // document.documentElement获取html节点
    console.log(document.documentElement);

    // 自定义节点的获取（父节点、子节点、同胞节点）
    // 子节点的获取:childNodes.返回的是一个数组NodeList节点列表，里面存放了指定节点所有的子节点
    var cs = document.body.childNodes;
    console.log(cs);
    console.log(cs[0]);
    // 大多浏览器会将body中的换行，空格，缩进处理为文本节点，所以通过childNodes获取指定节点的所有子节点时要
    // 注意是包含文本节点的
    // 获取第一个子节点
    // firstChild
    console.log(cs[5].firstChild);
    
    // 获取最后一个子节点
    // lastChild
    console.log(cs[1].lastChild);

    // 父节点的获取,一个元素节点的父节点不可能是一个文本节点，只能是元素节点
    // parentNode
    console.log(document.body.parentNode);
    p.parentNode.childNodes[5].childNodes[5].innerHTML = '找到你了';

    // 同胞关系
    // nextSibling:获取指定节点的后一个同胞节点
    console.log(cs[0].nextSibling);
    // previousSibling：获取指定节点的前一个同胞节点
    console.log(p.previousSibling);
    console.log(p.nextSibling.nextSibling.nextSibling.nextSibling.childNodes[5]);

    // 元素节点的获取
    // 子元素节点：children,只会获取指定节点的所有元素子节点，没有任何兼容问题，
    console.log(document.body.children);

    // 父元素节点：parentElement.存在兼容问题，IE678不支持
    console.log(p.parentElement);

    // 同胞元素节点：IE678不支持
    // nextElementSibling:获取指定节点的下一个元素同胞节点
    // previousElementSibling：获取指定节点的上一个元素同胞节点
    console.log(p.nextElementSibling);
    console.log(p.previousElementSibling);
    // 如果不存在指定关系的元素节点，那么会返回null

    // firstElementChild:获取指定节点的第一个元素子节点，IE678不支持
    // lastElementChild：获取指定节点的最后一个元素子节点，IE678不支持

    // document.getElementsByName():获取带有指定name属性值的元素集合
    //      更多的用于获取表单元素。
    var us = document.getElementsByName('username');
    var ps = document.getElementsByName('password');
    console.log(us);
    console.log(ps);

    // document.querySelector,document.querySelectorAll：选择器查询，需要参数是css选择器字符串，大多数css选择器都支持，
    // 但是不支持伪元素和伪类的查找
    console.log(document.querySelectorAll('span'));
    // 
    // document..getxx与document.queryxxx的区别
    // 1.get类型的需要的参数是具体值，而query类型需要的是选择器字符串
    // 2.get类型的没有兼容问题，而query类型的存在兼容问题，IE9一下不支持
    // 3.get类型的得到的是动态的元素集合，而query类型的得到的是静态的元素集合

    // get类型的和query类型的不仅仅只可以用于document.也可以用于元素节点，但是查找获取的范围就是在当前元素节点范围内
    // document.querySelectorAll('psan')查找获取的是文档中所有的span标签
    // div.querySelectorAll('psan')查找获取的是div中所有的span标签
</script>
</html>