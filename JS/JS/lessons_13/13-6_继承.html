<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>继承</title>
</head>

<body>

</body>
<script>
    // 继承：根据规则或特征提炼准则的不同，类的范围有所不同，将多个类间的相同特征写给一个公共类，
    // 这个就称为父类，字类的实例对象可以访问父类中定义的属性和方法，称为继承。js的继承是单继承。
    // 一个子类只能有一个父类，并且子类不能再作为父类的父类

    // 动物类
    function Animal(type,eat,play,voice) {
        this.type = type;
        this.eat = eat;
        this.play = play;
        this.voice = voice;
    }
    Animal.prototype.cell = '没有细胞壁';
    Animal.prototype.call = function(){
        console.log(this.voice);
    }

    // 1.构造函数继承

    // 狗类
    function Dog(type,eat,play,voice) {
        Animal.call(this,type,eat,play,voice);
        this.smell = '嗅觉灵敏，追踪能力强';
    }
    var dog = new Dog('犬科','肉','木棍','汪');
    console.log(dog);
    dog.call();

    // 猫类
    function Cat(type,eat,play,voice) {
        Animal.apply(this,[type,eat,play,voice]);
        this.dump = '有利爪，跳得高，可以爬树';
    }
    var cat = new Cat('猫科','🐟','球','喵');
    console.log(cat);
    cat.call();

    // 鸟类
    function Bird(type,eat,play,voice) {
        Animal.apply(this,[type,eat,play,voice]);
        this.fly = '拥有翅膀可以飞翔';
    }
    var bird = new Bird('鸟科','虫子','石子','叽叽');
    console.log(bird);
    bird.call();

    // 通过call（）方法和apply方法实现的继承称为构造函数继承，只能继承到父类构造函数中的属性和方法，
    // 无法继承父类原型中的属性和方法

    // 通过构造函数创建对象需要用到系统关键字 new
    // 1.创建了一个空对象object;
    // 2.将Aniaml中的this指向改变，变成了刚创建的空object；
    // 3.按顺序执行Animal的中的代码；
    // 4.return 返回添加了属性和方法的object；
    // var an1 = new Animal();
    // console.log(an1);

    // 所有函数都存在两个方法：call()/apply()可以改变指定函数中this的指向
    // 两个方法的共同点：第一个参数需要一个对象，表示将指定函数中的this指向改变为当前对象
    // 两个方法的区别：第二参数（可选参数），对于call方法第二参数需要一一列举，用‘，’隔开；而apply（）方法第二参数需要一个数组
    // function a(){
    //   // console.log(this)
    // }
    // var o = {id:'001'}
    // a.call(o);
    // a.apply(o);

</script>

</html>